### Java的IO流
#### 流的分类
* 1. **输入流**：只能读取数据
* 2. **输出流**：只能写入数据
* 输入流主要由InputStream和Reader作为基类
* 输出流主要由OutputStream和Writer作为基类
* 上面的四个基类都为抽象基类，**无法直接创建实例**。
* 字节流操作8个字节的数据单元，而字符流操作16个字节的数据单元。
* **结点流**（低级流）：可以从/向一个特定的IO设备读/写数据的流。
* **处理流**（高级流）：用于对一个已存在的流进行连接或封装，通过封装后的流来实现数据读/写功能。
* 处理流的好处：只要使用相同的处理流，程序就可以采用完全相同的输入/输出代码来访问不同的数据源。
#### 流的概念模型
* InputStream/Reader：所有输入流的基类，前者是字节输入流，后者是字符输入流。
* OutputStream/Writer：所有输出流的基类，前者是字节输出流，后者是字符输出流。
#### 输入/输出流体系
* 处理流用法：流的构造器参数是一个已经存在的流。
* 使用处理流的好处：进行输入/输出操作简单，执行效率高。
* 在使用处理流包装了底层节点流之后，关闭输入/输出流资源时，只要关闭最上层的处理流即可。
* 字符流：文本内容
* 字节流：二进制内容
* 转换流：字节流转换为字符流
* 推回输入流：推回输入流每次调用read()方法时总是先从推回缓冲区读取，读完推回缓冲区后还没有装满read()所需的数组时才会从原输入流中读取。（推回缓冲区默认长度为1）
#### 重定向标准输入/输出
* 标准输入：System.in
* 标准输出：System.out
* 重定向：改变标准输入输出的方式
#### RandomAccessFile（文件内容访问类）
* 特点：支持**随机访问**
* 局限：只能读写文件，不能读写其他IO节点
* mode参数：指定RandomAccessFile的访问模式。有以下四种：
* "r":以只方式打开指定文件
* "rw":以读、写方式打开指定文件
* "rws":以读、写方式打开指定文件，要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。
* "rwd":以读、写方式打开指定文件，要求对文件的内容的每个更新都同步写入到底层存储设备。
#### 对象序列化
* 将实现序列化的java对象转换为字节序列。序列化机制使得对象可以脱离程序的运行而独立存在。
* **Serializable**接口：标记接口，无须实现任何方法，表明该类的实例是可序列化的。
* 序列化一个对象：
* 1. 创建一个ObjectOutputStream输出流。
* 2. 调用ObjectOutputStream对象的writeObject()方法输出可序列化对象。
* 反序列化：
* 1. 创建一个ObjectInputStream输入流。
* 2. 调用ObjectInputStream对象的readObject()方法读取流的对象(需要强制类型转换)。
* 采用反序列化恢复Java对象时，必须提供该Java对象所属类的class文件。
* 所有保存到磁盘的对象都有一个序列化编号。
* 当试图序列化一个对象时，有以下两种情况：
* 1. 对象未被序列化：将该对象转换成字节序列并输出。
* 2. 对象已经被序列化过：程序只直接输出一个序列号编号。
* 上面方式存在问题：当程序序列化一个可变对象时，只有第一次使用writeObject()方法输出时才会将该对象转换成字节序列并输出，当程序再次调用writeObject()方法时，程序只是输出前面的序列化编号，即使后面该对象的实例变量已被改变，改变的实例变量值也不会被输出。
* **transient关键字**：实例变量前面使用transient关键字修饰，可以指定Java序列化时无须理会该实例变量。**transient关键字只能修饰实例变量，不可修饰其他成分**。
* writeReplace()方法：实现序列化某个对象时替换该对象。
* **Externalizable接口**：强制自定义序列化
* 与**Serializable接口**的不同：
* 1. 接口必须实现接口内的两个方法：readExternal()和writeExternal()方法。
* 2. 序列化的类必须提供无参数的构造器。