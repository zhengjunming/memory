# Java关键字与保留字总结

### 关键字分类



![](C:\Users\郑俊铭\Desktop\QG\1.png)

![](C:\Users\郑俊铭\Desktop\QG\2.png)

### 关键字解析

1. **boolean**：布尔数据类型，属于基本数据类型。只有true和false两个。boolean型变量默认初始值为false。一般用于条件的判断一个循环的结束条件。

2. **byte**：整型，属于基本数据类型。一个byte类型整数在内存中占8位，表数范围为$-2^7(-128)$~$2^7-1(127)$。

3. **char**：字符型，属于基本数据类型。字符型值使用必须用单引号括起来。为16位的Unicode字符集。表数范围为：0~$2^{15}-1$。

4. **double**：双精度浮点型，属于基本数据类型。编译器默认的浮点型为double型，表数范围为$-2^{63}$~$2^{63}-1$。 对于double类型数值，第一位为符号位，接下来11位表示指数，在接下来的52位表示尾数。一般浮点数不应该进行运算，这样容易发生精度缺失。浮点数的运算应该使用**BigDecima**l类。

5. **float**： 单精度浮点型，属于基本数据类型。定义初始化值时要在数值后面加上f或F的结尾。表数范围为$-2^{31}$~$2^{31}-1$。

6. **int**：整型，属于基本数据类型。一个int类型整数在内存中占32位，表数范围为$-2^{31}$~$2^{31}-1$。

7. **long**：长整型，属于基本数据类型。一个long类型整数在内存中占64位，表数范围为$-2^{63}$~$2^{63}-1$。

8. **short**：短整型，属于基本数据类型。一个short类型整数在内存中占16位，表数范围为$-2^{15}$~$2^{15}-1$。

9. **void**：标记一个方法没有返回值。也可以用来表示一句没有任何功能的语句。

10. **class**：用来声明新的*Java* 类，该类是相关变量和/或方法的集合。

11. **enum**：用来定义一个枚举类。

12. **interface**：用来声明新的 Java 接口，接口是方法的集合。接口是 Java 语言的一项强大功能。任何类都可声明（通过**implements**关键字）它实现一个或多个接口，实现了接口的任何类都必须提供在该接口中的所有方法的实现。接口里定义的成员变量只能是常量；接口里定义的普通方法只能是public的抽象方法；在接口中定义默认方法，需要使用default修饰；在接口中定义类方法，需要使用static修饰。接口不能用于创建实例，但可用于声明引用类型变量。

13. **super**：用于引用使用该关键字的类的超类（父类）。使用super限定可以调用父类被子类覆盖的实例方法，构造器。

14. **this**：同类的引用。

    - 构造器中引用该构造器正在初始化的对象。
    - 在方法中引用调用该方法的对象。
    - 作用：让类中的一个方法，访问该类里的另一个方法或实例变量。
    - 对象的一个成员直接调用另一个成员时，可以省略this前缀。
    - static修饰的方法中不能使用this引用。
    - 使用**外部类类名.this.变量名**访问外部类成员变量，使用**this.变量名**访问内部类成员变量，使用**变量名**访问内部类局部变量。

15. **extend**：继承。用在 class 或 interface 声明中，用于指示所声明的类或接口是其名称后跟有 extends 关键字的类或接口的子类。子类继承父类的所有 public 和 protected 变量和方法。 子类可以重写父类的任何非 final 方法。一个类只能扩展一个其他类。但可以继承多个接口。

16. **implements**：实现接口类。在 class 声明中使用，以指示所声明的类提供了在 implements 关键字后面的名称所指定的接口中所声明的所有方法的实现。类必须提供在接口中所声明的所有方法的实现。一个类可以实现多个接口。

17. **instanceof**：用来确定对象所属的类。

18. **new**：用于创建类的新实例。new 关键字后面的参数必须是类名，并且类名的后面必须是一组构造方法参数（必须带括号）。

    参数集合必须与类的构造方法的签名匹配。= 左侧的变量的类型必须与要实例化的类或接口具有赋值兼容关系。

19. **import**：使一个包中的一个或所有类在当前 Java 源文件中可见。可以不使用完全限定的类名来引用导入的类。如果引用List类，一般用**import java.util.List;** 而不会用**import java.util.*;** 因为这样会使程序变得难阅读。

20. **package**：package 关键字指定在 Java 源文件中声明的类所驻留的 Java 包。package 语句（如果出现）必须是 Java 源文件中的**第一个非注释性文本。**

    例:java.lang.Object。

    如果 Java 源文件不包含 package 语句，在该文件中定义的类将位于“默认包”中。请注意，不能从非默认包中的类引用默认包中的类。

21. **null**：null 是 Java 的保留字，表示无值。将 null 赋给非原始变量相当于释放该变量先前所引用的对象。不能将 null 赋给原始类型（byte、short、int、long、char、float、double、boolean）变量。

22. **true**：真，表示 boolean 变量的两个合法值之一。

23. **false**：假，表示 boolean 变量的两个合法值之一

24. **const**：静态，是一个保留字，是一个类型修饰符，使用const声明的对象不能更新。与final某些类似。

25. **goto**：跳转。保留关键字。一般不会使用。    

26. **private**：私有的。访问控制修饰符，可以应用于类、方法或字段（在类中声明的变量）。 只能在声明 private（内部）类、方法或字段的类中引用这些类、方法或字段。在类的外部或者对于子类而言，它们是不可见的。

27. **protected**：受保护的。访问控制修饰符，可以应用于类、方法或字段（在类中声明的变量）。可以在声明 protected 类、方法或字段的类、同一个包中的其他任何类以及任何子类（无论子类是在哪个包中声明的）中引用这些类、方法或字段。

28. **public**：公共的。访问控制修饰符，可以应用于类、方法或字段（在类中声明的变量）。 可能只会在其他任何类或包中引用 public 类、方法或字段。**所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。**

29. **abstract**：声明抽象。abstract关键字可以修改类或方法。abstract类可以扩展（增加子类），但不能直接实例化。abstract方法不在声明它的类中实现，但必须在某个子类中重写。采用 abstract方法的类本来就是抽象类，并且必须声明为abstract。抽象类里定义的构造器只能是普通的构造器。final和abstract不能同时使用。private与abstract不能同时修饰方法。static与abstract不能同时修饰某个方法，但可以同时修饰内部类。

30. **final**：final 关键字可以应用于类，以指示不能扩展该类（不能有子类）。final 关键字可以应用于方法，以指示在子类中不能重写此方法。final 修饰的**成员变量**必须显示地指定初始值。使用final修饰的引用类型变量不能被重新赋值，但可以改变引用类型变量所引用对象的内容。

    final修饰的类变量、实例变量能指定初始值的地方：

    * **类变量**，必须在静态初始化块中指定初始值或声明该类变量时指定初始值。
    * **实例变量**， 必须在非静态初始化快、声明该实例变量或构造器中指定初始值。

    如果打算在构造器、初始化块中对final成员变量进行初始化，则不要在初始化之前就访问成员变量的值。例如下面代码将引起错误：

    ```
          final int age;
          {
            System.out.println(age);
            age = 19;
          }
    ```
    **可执行 “宏替换”的final变量**

    final变量只要满足三个条件，这个final变量就不再是一个变量，而是相当于一个直接量。

    * 使用final修饰符修饰
    * 在定义该final变量时指定了初始值
    * 该初始值可以在编译时就被确定下来

    **创建自定义不可变类：**  

    * 使用private和final修饰符来修饰该类的成员变量。
    * 提供带参数构造器，用于根据传入参数来初始化类里的成员变量。
    * 仅为该类的成员变量提供getter方法，不提供setter方法。
    * 如果有必要，重写Object类的hashCode()和equals()方法。

31. **native：本地**

    native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。

    JNI是Java本机接口（Java Native Interface），是一个本机编程接口，它是Java软件开发工具箱（Java Software Development Kit，SDK）的一部分。JNI允许Java代码使用以其他语言编写的代码和代码库。Invocation API（JNI的一部分）可以用来将Java虚拟机（JVM）嵌入到本机应用程序中，从而允许程序员从本机代码内部调用Java代码。

    JNI的书写步骤如下：

    - 编写带有native声明的方法的Java类

      ```
      public class HelloWorld {

          public native void displayHelloWorld();

          static {
              System.loadLibrary("hello");
          }

          public static void main(String[] args) throws Exception {
              new HelloWorld().displayHelloWorld();
          }

      }
      ```

    - 使用javac命令编译编写的Java类：

    - 使用java -jni HelloWorld来生成后缀名为.h的头文件

    - 使用其他语言（C、C++）实现本地方法

          #include <stdio.h>
          #include <jni.h> // 在%JAVA_HOME%/include目录，需导入
          #include <HelloWorld.h> // 编译生成，需导入
          #include <jni_md.h> // 在%JAVA_HOME%/include/win32目录，需导入
          JNIEXPORT void JNICALL Java_HelloWorld_displayHelloWorld(JNIEnv *env, jobject obj)
          
          {
          	printf("Hello world!/n");
          	return;
          }

    - 将本地方法编写的文件生成动态链接库：需要生成dll文件。需要创建DLL工程。命名为HelloWorld

    - 运行Java程序，调用DLL文件。

        将上一步骤中的HelloWorld.dll文件拷贝到HelloWorld.class所在的文件中。注意dll的文件名要与Java代码中 System.loadLibrary("hello"); 保持一致。如果不一致可以自己修改文件名。

32. **static**：**静态**

    static 关键字可以应用于内部类、方法或字段（类的成员变量）。

    通常，static 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用。static修饰的成员表明它属于这个类本身，而不属于该类的单个实例。把static修饰的成员变量和方法也称为类变量、类方法。静态成员不能直接访问非静态成员。static修饰的方法中不能使用this引用。static（内部）类可以被其他类实例化和引用（即使它是顶级类）。static 字段（类的成员变量）在类的所有实例中只存在一次。可以从类的外部调用 static 方法，而不用首先实例化该类。即使没有显示地声明为static，类的**构造器**实际上也是静态方法。

33. **strictfp**：strictfp的意思是FP-strict，也就是说精确浮点的意思。在Java虚拟机进行浮点运算时，如果没有指定strictfp关键字时，Java的编译器以及运行环境在对浮点运算的表达式是采取一种近似于我行我素的行为来完成这些操作，以致于得到的结果往往无法令人满意。而一旦使用了strictfp来声明一个类、接口或者方法时，那么所声明的范围内Java的编译器以及运行环境会完全依照浮点规范IEEE-754来执行。

    可以将一个类、接口以及方法声明为strictfp，但是不允许对接口中的方法以及构造函数声明strictfp关键字。

    ```
    strictfp interface A {}
    public strictfp class A {
        strictfp void f() {}
    }
    ```

34. **synchronized**：**线程、同步**

    synchronized 关键字可以应用于方法或语句块，并为一次只应由一个线程执行的关键代码段提供保护。

    当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。

    如果应用于静态方法，那么，当该方法一次由一个线程执行时，整个类将被锁定。

    如果应用于实例方法，那么，当该方法一次由一个线程访问时，该实例将被锁定。

    如果应用于对象或数组，当关联的代码块一次由一个线程执行时，对象或数组将被锁定。

    synchronized 方法的缺陷：若将一个大的方法声明为synchronized 将会大大影响效率。

    **同步代码块语法：** synchronized(受益对象){代码块}    

    对**synchronized(this)**的一些理解 

    * 当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。
    * 当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。 
    * 当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。  

    **同步方法同同步代码块的区别 **    

    * 同步方法，是通过this关键字找到当前对象，将当前对象上锁     
    * 同步代码块，可以指定任意一个对象     
    * 同步代码块，可以控制的更具体

35. **transient**：用来表示一个域不是该对象序列化的一部分。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中。只能用于修饰实例变量，不可修饰其他成分。

36. **volatile**：**易失**

    volatile 关键字用于表示可以被多个线程异步修改的成员变量。

    一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

    * 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
    * 禁止进行指令重排序。

    使用volatile必须具备以下2个条件：

    * 对变量的写操作不依赖于当前值 
    * 该变量没有包含在具有其他变量的不变式中

    volatile 关键字在许多 Java 虚拟机中都没有实现。 volatile 的目标用途是为了确保所有线程所看到的指定变量的值都是相同的。

    Java 语言中的 volatile 变量可以被看作是一种 “程度较轻的 synchronized”；与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是 synchronized 的一部分。

    **Java内存模型**：定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。所以，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。Java内存模型规定所有的变量都是存在主存当中，每个线程都有自己的工作内存。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。

    **指令重排序**：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。

    **指令重排序**不会影响单个线程的执行，但是会影响到线程并发执行的正确性。也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。

    * 原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。
    * 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 
    * 有序性：即程序执行的顺序按照代码的先后顺序执行。

    **happens-before原则（先行发生原则）：**

    1. 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；
    2. 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；
    3. volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
    4. 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；
    5. 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；
    6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
    7. 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；
    8. 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；

    synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，**因为volatile关键字无法保证操作的原子性。** 

37. **case**： 返回观察结果。用来标记 switch 语句中的每个分支。case 块没有隐式结束点。break 语句通常在每个 case 块末尾使用，用于退出 switch 语句。如果没有 break 语句，执行流将进入所有后面的 case 和/或 default 块。

38. **default**：用来标记 switch 语句中的默认分支。default 块没有隐式结束点。break 语句通常在每个 case 或 default 块的末尾使用，以便在完成块时退出 switch 语句。如果没有 default 语句，其参数与任何 case 块都不匹配的 switch 语句将不执行任何操作。

39. **do**：用于指定一个在每次迭代结束时检查其条件的循环。do 循环体至少执行一次。条件表达式后面必须有分号。

40. **else**：在 if-else 语句中与 if 关键字结合使用。else 子句是可选的，如果 if 条件为 false，则执行该子句。

41. **for**：用于指定一个在每次迭代结束前检查其条件的循环。for 语句的形式为 for(initialize; condition; increment)，控件流进入 for 语句时，将执行一次 initialize 语句。每次执行循环体之前将计算 condition 的结果。如果 condition 为 true，则执行循环体。每次执行循环体之后，在计算下一个迭代的 condition 之前，将执行 increment 语句。

42. **if**：if 关键字指示有条件地执行代码块。条件的计算结果必须是布尔值。if 语句可以有可选的 else 子句，该子句包含条件为 false 时将执行的代码。包含 boolean 操作数的表达式只能包含 boolean 操作数。

43. **switch**：switch 语句用于基于某个表达式选择执行多个代码块中的某一个。switch 条件的计算结果必须等于 byte、char、short 或 int。

44. **while**：用于指定一个只要条件为真就会重复的循环。

45. **break**：用于提前退出 for、while 或 do 循环，或者在 switch 语句中用来结束 case 块。break 总是退出最深层的 while、for、do 或 switch 语句。

46. **continue**：用来跳转到 for、while 或 do 循环的下一个迭代。continue 总是跳到最深层 while、for 或 do 语句的下一个迭代。

47. **return**：会导致方法返回到调用它的方法，从而传递与返回方法的返回类型匹配的值。如果方法具有非 void 的返回类型，return 语句必须具有相同或兼容类型的参数。

48. **assert：断言表达式是否为真**

    用法：

    1、assert true(false);

    如果为true，则程序继续执行。

    如果为false，则程序抛出AssertionError，并终止执行。

    2、assert : <错误信息表达式>

    如果为true，则程序继续执行。

    如果为false，则程序抛出java.lang.AssertionError，并输入<错误信息表达式>。

    **扩展：Assert类——广泛用于单元测试**

    Assert类提供了一系列的编写测试的有用的声明方法。只有失败的声明方法才会被记录。Assert 类的重要方法列式如下：

    * void assertEquals(boolean expected, boolean actual)

      检查两个变量或者等式是否平衡

    * void assertFalse(boolean condition)

      检查条件是假的

    * void assertNotNull(Object object)

      检查对象不是空的

    * void assertNull(Object object)

      检查对象是空的

    * void assertTrue(boolean condition)

      检查条件为真

    * void assertSame(boolean condition)

      检查两个相关对象是否指向同一个对象

    * void assertNotSame(boolean condition)

      检查两个相关对象是否不指向同一个对象

    *  void assertArrayEquals(expectedArray, resultArray)
      检查两个数组是否相等

    * void fail()
      在没有报告的情况下使测试不通过

49. **finally**：标记try异常处理语句的无条件执行代码分支。用来执行一段代码不管在前面定义的try语句中是否有异常或运行时错误发生（一定会执行）。finally块必须位于所有的catch块之后。使用 finally 可以维护对象的内部状态，并可以清理非内存资源。

50. **catch**：**处理异常**

    catch 关键字用来在 try-catch 或 try-catch-finally 语句中定义异常处理块。开始和结束标记 { 和 } 是 catch 子句语法的一部分，即使该子句只包含一个语句，也不能省略这两个标记。每个 try 块都必须至少有一个 catch 或 finally 子句。

51. **throw**：**抛出一个异常对象**

    throw 关键字用于引发异常。throw 语句将 java.lang.Throwable 作为参数。Throwable 在调用栈中向上传播，直到被适当的 catch 块捕获。

52. **throws**：**声明一个异常可能被抛出**

    throws 关键字可以应用于方法，以便指出方法引发了特定类型的异常。throws 关键字将逗号分隔的 java.lang.Throwables 列表作为参数。引发非 RuntimeException 异常的任何方法还必须在方法声明中使用 throws 修饰符来声明它引发的异常。要在 try-catch 块中包含带 throws 子句的方法的调用，必须提供该方法的调用者。

53. **try**：**捕获异常**

    try 关键字用于包含可能引发异常的语句块。每个 try 块都必须至少有一个 catch 或 finally 子句。如果某个特定异常类未被任何 catch 子句处理，该异常将沿着调用栈递归地传播到下一个封闭 try 块。如果任何封闭 try 块都未捕获到异常，Java 解释器将退出，并显示错误消息和堆栈跟踪信息。

    ​