1. 实际的的数组对象（实际对象）被储存在**堆内存**中，如果引用该数组对象的数组引用变量（其他引用变量）是一个局部变量，那么它被存储在**栈内存**中。
2. 构造器是一个类创建对象的根本途径。分为**有参构造器**和**无参构造器**。
3. **static**关键字：可用于修饰方法、成员变量等成员，static修饰的成员表明它属于这个类本身，而不属于该类的单个实例。把static修饰的成员变量和方法也称为类变量、类方法。静态成员不能直接访问非静态成员。
4. **对象的this引用**：
    * 构造器中引用该构造器正在初始化的对象。
    * 在方法中引用调用该方法的对象。
    * 作用：让类中的一个方法，访问该类里的另一个方法或实例变量。
    * 对象的一个成员直接调用另一个成员时，可以省略this前缀。
    * static修饰的方法中不能使用this引用。
5. 成员变量和局部变量
  ![image](C:\Users\郑俊铭\Downloads\未命名文件.png)
* 如果方法里的局部变量和成员变量同名，局部变量会覆盖成员变量，如果需要在这个方法里引用被覆盖的成员变量，则可使用this（对于实例变量）或类名（对于类变量）作为调用者类限定访问成员变量。
6. java的子类不能获得父类的构造器。

7. 如果需要在子类方法中调用父类被覆盖的实例方法，则可使用**super**限定来调用父类被覆盖的实例方法。

8. super调用的是父类的构造器，this调用的是同一个类中重载的构造器。

9. 当调用子类构造器来初始化子类对象时，父类构造器总会在子类构造器之前执行。

10. java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，就可能出现**多态**。

11. 对象的实例变量不具有多态性。

12. 类初始化阶段，先执行最顶层父类的静态初始化块，然后依次向下，直到执行当前类的静态初始化块。

13. 对象初始化阶段，先执行最顶层父类的初始化块、最顶层父类的构造器，然后依次依次向下，直到执行当前类的初始化块，当前类的构造器。

14. **单例类**创建对象不能通过构造器，只能通过getter方法来得到实例。

15. **final **修饰的成员变量必须显示地指定初始值。

    * **类变量**，必须在静态初始化块中指定初始值或声明该类变量时指定初始值。

    * **实例变量**， 必须在非静态初始化快、声明该实例变量或构造器中指定初始值。

    * 如果打算在构造器、初始化块中对final成员变量进行初始化，则不要在初始化之前就访问成员变量的值。例如下面代码将引起错误：

      ```
      final int age;
      {
        System.out.println(age);
        age = 19;
      }
      ```

16. 使用final修饰的引用类型变量不能被重新赋值，但可以改变引用类型变量所引用对象的内容。

17. final修饰的方法不可被重写。final修饰的类不可被继承。

18. 抽象类的构造器不能用于创建实例，主要是用于被其子类调用。抽象类不能被实例化。抽象类可以包含成员变量、方法、构造器、初始化块、内部类（接口、枚举）。抽象类里定义的构造器只能是普通构造器。

19. 接口里定义的成员变量只能是常量；接口里定义的普通方法只能是public的抽象方法；在接口中定义默认方法，需要使用default修饰；在接口中定义类方法，需要使用static修饰。

20. **静态内部类 **，方法里定义的内部类被称为**局部内部类**。

21. 使用**外部类类名.this.变量名**访问外部类成员变量，使用**this.变量名**访问内部类成员变量，使用**变量名**访问内部类局部变量。

22. 根据静态成员不能访问非静态成员的规则，外部类的静态方法、静态代码块不能访问非静态内部类。静态内部类不能访问外部类的实例成员，只能访问外部类的类成员。

23. **静态内部类**是外部类的一个静态成员，外部类的所有方法、所有初始化块中可以使用静态内部类来定义变量、创建对象。

24. 外部类不能直接访问静态内部类的成员，但可以使用静态内部类作为调用者来访问静态内部类的类成员，也可以使用静态内部类对象作为调用者来访问静态内部类的实例成员。

25. 接口内部类只能是静态内部类。

26. 创建非静态内部类对象之前，必须先创建其外部类对象；非静态内部类的构造器必须使用外部类对象来调用。

